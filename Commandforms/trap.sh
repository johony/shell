# 列出信号列表
kill -l
trap -l

# 每个信号列表都有一个特定的数字代码，如SIGINT的代码为2.信号名称以SIG开头，也可以省略不写，也就是说SIGINT和INT是相同的。
# 信号名称不区分大小写。在传递信号时，可以使用数字代码，也可以使用信号名称(使用信号名称移植性更高)。


# 使用内置命令kill传递信号
kill -信号 进程编号
# 或
kill -s 信号 进程编号
# 或
kill -n 信号 进程编号
# 其中-n可以使用信号代码或信号名称。kill后可接多个进程编号，kill会把指定的信号都传送给这些进程。

HUP   #重新启动进程
INT   #按Ctrl-C键；中断程序
OUIT  #按Ctrl-\键；以内核转储的方式离开程序

# TERM信号是要让进程在结束前，有机会执行清理动作，如关闭暂存盘，完成后再结束进程。
# 这是比较优雅地终止进程的方法。
# 不过TERM没有强制性，该进程未必会理会TERM信号
TERM  #终止进程

# KILL信号会强制结束进程。接到这个信号，进程就不会进行清理的动作，而是马上结束。
KILL  #强制删除进程

# 假设执行top后，top的PID为12345，执行kill -STOP 12345后，会出现[1]+ Stopped top的信息，
# 这表示top进程已暂时停止，键盘的控制权交回给使用者。如果要回复top，可在命令行执行fg命令。
# fg命令会发出CONT信号给to进程，让top在前台中继续执行。
STOP  #暂停进程

# CONT信号通知进程继续执行。前台程序fg和后台程序bg，均会对暂停执行的进程发出CONT信号。
CONT  #继续执行

# TSTP信号是在终端中，让进程暂时停止执行。当使用者键入Ctrl-z时，可对进程发出TSTP信号。
TSTP  #按Ctrl-Z键；在终端中暂停进程

# ABRT信号是呼叫abort涵式放弃进程，如果有必要，会产生core dump信息
ABRT  #放弃进程，并转存内核信息

# SEGV对进程发出记忆区段错误的信号，该进程会中止执行，若有必要，会产生core dump信息。
SEGV  #内存区段错误，并转存核心信息


# trap的运用
# trap语法1
trap "触发指令" 信号串行
# 想Shell注册信号，只要系统产生此特定的信号，trap指令就会触发，并执行trap命令中的"触发指令"。
trap 'echo "收到ABRT信号..."' ABRT

# 向当前Shell发出ABRT信号的方法：
kill -ABRT $$

# 注：Bash会对trap指令读取两次，一次是读取trap指令内容时，一次是执行触发指令时。因此，最好使用单引号包括"触发指令"，
# 以免Bash先对它进行变量替换等动作，影响触发指令的正常执行。

# trap - 信号串行
# 如果trap的语法中没有触发指令，而是-或空白，则可回复信号串行原本的作用
trap '-' ABRT

# trap '' 信号串行
# 忽略系统发出的"信号串行"
# 如果"触发指令"的部分是空字符串"，那么Shell会忽略这些"信号串行"，不做任何反应
